def solution(n, m, x, y, queries):                                                          # 정답은 사각형 모양의 범위로 나오므로
    rec = [-x, x, -y, y]                                                                    # [lx, rx, ly, ry] 형태로 좌측 하단, 우측 상단 좌표를 저장, 이 때 하단은 계산을 위해 -를 붙여저장
    info = [[3, 2, 0, m - 1], [2, 3, -m + 1, 0], [1, 0, 0, n - 1], [0, 1, -n + 1, 0]]       # 각 방향마다 수정해야 할 정보들을 저장
    while queries:                                                                          # 마지막 위치로부터 쿼리를 거꾸로 탐색
        d, dx = queries.pop()                                                               # 방향과 거리를 불러옴
        i, j, l, r = info[d]                                                                # i, j는 방향마다 갱신해야 하는 x들 혹은 y들 좌표의 인덱스, l, r은 그 에 따른 범위
        rec[i] = min(rec[i] + dx, r)                                                        # 예) 왼쪽 이동(d=0)인 경우 오른쪽 열좌표인(ry=rec[3])를 dx만큼 늘려주는데 최대범위(r)를 넘어서지 않도록 함
        if rec[j] < -l:                                                                     # 오른쪽이동(d=1)의 경우 ly를 -ly로 표현하였으므로 ry의 경우와 같이 옮겨줌 범위는 마찬가지로 r을 넘어서지 않도록 함
            rec[j] -= dx                                                                    # (d=0)인 경우 왼쪽좌표(ly=rec[2])는 격자의 가장자리일 경우 그대로 두고(밀어도 상관없으므로)
            if rec[j] < -r:                                                                 # 가장자리가 아닐경우 똑같이 dx만큼 옮겨줌
                return 0                                                                    # 이 때, ry가 최대 범위를 넘는것은 괜찮지만 ly가 넘어간다면 (x, y)는 해당 쿼리로 이동할 수 없는 좌표이므로 0 리턴
    return (rec[0] + rec[1] + 1) * (rec[2] + rec[3] + 1)


# print(solution(2, 5, 0, 1, [[3, 1], [2, 2], [1, 1], [2, 3], [0, 1], [2, 1]]))
